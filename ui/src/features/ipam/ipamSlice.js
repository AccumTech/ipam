import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';
import {
  fetchSpaces,
  fetchVNets,
  fetchSubnets,
  fetchEndpoints,
  refreshAll,
  getMe
} from './ipamAPI';

const initialState = {
  refreshInterval: 1,
  isAdmin: true,
  spaces: null,
  blocks: null,
  vNets: null,
  subnets: null,
  endpoints: null,
  refreshing: false,
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchSpacesAsync = createAsyncThunk(
  'ipam/fetchSpaces',
  async (token) => {
    const response = await fetchSpaces(token, true);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const fetchVNetsAsync = createAsyncThunk(
  'ipam/fetchVNets',
  async (token) => {
    const response = await fetchVNets(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const fetchSubnetsAsync = createAsyncThunk(
  'ipam/fetchSubnets',
  async (token) => {
    const response = await fetchSubnets(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const fetchEndpointsAsync = createAsyncThunk(
  'ipam/fetchEndpoints',
  async (token) => {
    const response = await fetchEndpoints(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const refreshAllAsync = createAsyncThunk(
  'ipam/refreshAll',
  async (token) => {
    const response = await refreshAll(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const getMeAsync = createAsyncThunk(
  'ipam/getMe',
  async (token) => {
    const response = await getMe(token);
    // The value we return becomes the `fulfilled` action payload
    return response;
  }
);

export const ipamSlice = createSlice({
  name: 'ipam',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {},
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchSpacesAsync.fulfilled, (state, action) => {
        state.spaces = action.payload;

        state.blocks = action.payload.map((space) => {
          space.blocks.forEach(block => {
            block.parentSpace = space.name;
            block.available = (block.size - block.used);
            block.utilization = Math.round((block.used / block.size) * 100);
            block.id = `${block.name}@${block.parentSpace}`;
          });

          return space.blocks;
         }).flat();
      })
      .addCase(fetchVNetsAsync.fulfilled, (state, action) => {
        state.vNets = action.payload;
      })
      .addCase(fetchSubnetsAsync.fulfilled, (state, action) => {
        state.subnets = action.payload;
      })
      .addCase(fetchEndpointsAsync.fulfilled, (state, action) => {
        state.endpoints = action.payload;
      })
      .addCase(refreshAllAsync.fulfilled, (state, action) => {
        state.refreshing = false;
        state.spaces = action.payload[0];

        state.blocks = action.payload[0].map((space) => {
          space.blocks.forEach(block => {
            block.parentSpace = space.name;
            block.available = (block.size - block.used);
            block.utilization = Math.round((block.used / block.size) * 100);
            block.id = `${block.name}@${block.parentSpace}`;
          });

          return space.blocks;
         }).flat();

        state.vNets = action.payload[1];
        state.subnets = action.payload[2];
        state.endpoints = action.payload[3];
      })
      .addCase(refreshAllAsync.pending, (state) => {
        state.refreshing = true;
      })
      .addCase(refreshAllAsync.rejected, (state, action) => {
        state.refreshing = false;
        console.log("REFRESH ALL REJECTED");
        console.log("-----------------");
        console.log(action.error);
        console.log("-----------------");
      })
      .addCase(getMeAsync.fulfilled, (state, action) => {
        if(state.refreshInterval != action.payload['apiRefresh']) {
          state.refreshInterval = action.payload['apiRefresh'];
        }

        state.isAdmin = action.payload['isAdmin'];
      })
      .addCase(getMeAsync.rejected, (state, action) => {
        console.log("GET ME REJECTED");
        console.log("-----------------");
        console.log(action.error);
        console.log("-----------------");
      });
  },
});

export const { increment, decrement, incrementByAmount } = ipamSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
// export const selectCount = (state) => state.counter.value;

export const getRefreshInterval = (state) => state.ipam.refreshInterval;
export const getAdminStatus = (state) => state.ipam.isAdmin;
export const getRefreshing = (state) => state.ipam.refreshing;

export const selectSpaces = (state) => state.ipam.spaces;
export const selectBlocks = (state) => state.ipam.blocks;
export const selectVNets = (state) => state.ipam.vNets;
export const selectSubnets = (state) => state.ipam.subnets;
export const selectEndpoints = (state) => state.ipam.endpoints;

export default ipamSlice.reducer;
